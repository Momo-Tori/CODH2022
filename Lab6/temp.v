module cache #(
           parameter LINE_ADDR_LEN = 3,  // line内地址?度，决定了每个line具有2^3个word
           parameter SET_ADDR_LEN = 3,  // 组地址?度，决定了一共有2^3=8组
           parameter TAG_ADDR_LEN = 6,  // tag?度
           parameter WAY_CNT = 3 // 组相连度，决定了每组中有多少路line
       )(
           input clk, rst,
           output miss,  // 对CPU发出的miss信号
           input [31: 0] addr,  // 读写请求地址
           input rd_req,  // 读请求信号
           output reg [31: 0] rd_data,  // 读出的数据，一次读一个word
           input wr_req,  // 写请求信号
           input [31: 0] wr_data // 要写?的数据，?次写一个word
       );
localparam MEM_ADDR_LEN = TAG_ADDR_LEN + SET_ADDR_LEN ; // 计算主存地址?度 MEM_ADDR_LEN，主存?小=2^MEM_ADDR_LEN个line
localparam UNUSED_ADDR_LEN = 32 - TAG_ADDR_LEN - SET_ADDR_LEN - LINE_ADDR_LEN - 2 ; // 计算未使?的地址的?度
localparam LINE_SIZE = 1 << LINE_ADDR_LEN ; // 计算 line 中 word 的数量，即 2^LINE_ADDR_LEN 个word 每 line
localparam SET_SIZE = 1 << SET_ADDR_LEN ; // 计算一共有多少组，即 2^SET_ADDR_LEN 个组
reg [ 31: 0] cache_mem [SET_SIZE][WAY_CNT][LINE_SIZE]; // SET_SIZE个line，每个line有LINE_SIZE个word
reg [TAG_ADDR_LEN - 1: 0] cache_tags [SET_SIZE][WAY_CNT]; // SET_SIZE个TAG
reg valid [SET_SIZE][WAY_CNT]; // SET_SIZE个valid(有效位)
reg dirty [SET_SIZE][WAY_CNT]; // SET_SIZE个dirty(脏位)
wire [ 2 - 1: 0] word_addr; // 将输?地址addr拆分成这5个部分
wire [ LINE_ADDR_LEN - 1: 0] line_addr;
wire [ SET_ADDR_LEN - 1: 0] set_addr;
wire [ TAG_ADDR_LEN - 1: 0] tag_addr;
wire [UNUSED_ADDR_LEN - 1: 0] unused_addr;
enum {IDLE, SWAP_OUT, SWAP_IN, SWAP_IN_OK} cache_stat; // cache 状态机的状态定义
// IDLE代表就绪，SWAP_OUT代表正在换出，SWAP_IN代表正在换?，SWAP_IN_OK代表换?后进??周期的写?cache操作
reg [ SET_ADDR_LEN - 1: 0] mem_rd_set_addr = 0;
reg [ TAG_ADDR_LEN - 1: 0] mem_rd_tag_addr = 0;
wire [ MEM_ADDR_LEN - 1: 0] mem_rd_addr = {mem_rd_tag_addr, mem_rd_set_addr};
reg [ MEM_ADDR_LEN - 1: 0] mem_wr_addr = 0;
reg [31: 0] mem_wr_line [LINE_SIZE];
wire [31: 0] mem_rd_line [LINE_SIZE];
wire mem_gnt; // 主存响应读写的握?信号
assign {unused_addr, tag_addr, set_addr, line_addr, word_addr} = addr; // 拆分 32bit ADDR
reg cache_hit = 1'b0;
enum {FIFO, LRU} swap_out_strategy;
integer time_cnt; //LRU时间记录
reg [WAY_CNT - 1: 0] way_addr; //空闲位置
reg [WAY_CNT - 1: 0] out_way; //换出位置
reg [15: 0] LRU_record[SET_SIZE][WAY_CNT]; //每?项的LRU记录
reg [WAY_CNT: 0] FIFO_record[SET_SIZE][WAY_CNT]; //每?组内的FIFO排位记录
always @ ( * ) begin // 判断输?的address 是否在 cache 中命中,如果没有命中，需要在之后设置换出策略
    cache_hit = 1'b0;
    for (integer i = 0; i < WAY_CNT; i = i + 1)
    begin
        if (valid[set_addr][i] && cache_tags[set_addr][i] == tag_addr) // 如果 cache line有效，并且tag与输?地址中的tag相等，则命中
        begin
            cache_hit = 1'b1;
            way_addr = i;
        end
    end
end
always @ ( * ) begin
    if (~cache_hit & (wr_req | rd_req))
    begin
        //LRU策略选出冲突时换处的块
        if (swap_out_strategy == LRU)
        begin
            for (integer i = 0; i < WAY_CNT; i = i + 1 )
            begin
                out_way = 0;
                if (LRU_record[set_addr][i] < LRU_record[set_addr][out_way])
                begin
                    out_way = i;
                end
            end
        end
        //FIFO策略选出冲突时换出的块
        else
        begin
            integer free = 0; //是否有空闲块的标志
            for (integer i = 0;i < WAY_CNT ;i = i + 1 )
            begin
                if (FIFO_record[set_addr][i] == 0)
                begin
                    out_way = i;
                    free = 1;
                    break;
                end
            end
            if (free == 0)
            begin
                for (integer i = 0;i < WAY_CNT ;i = i + 1)
                begin //此时说明时最早进去的
                    if (FIFO_record[set_addr][i] == WAY_CNT)
                    begin
                        out_way = i;
                        FIFO_record[set_addr][i] = 0; /*my adding*/
                        break;
                    end
                end
            end
            if (FIFO_record[set_addr][out_way] == 0)
            begin
                for (integer i = 0;i < WAY_CNT ;i = i + 1 )
                begin
                    if (FIFO_record[set_addr][i] != 0) begin
                        FIFO_record[set_addr][i] = FIFO_record[set_addr][i] + 1;
                    end
                end
            end
            FIFO_record[set_addr][out_way] = 1;
        end
    end
end
always @ (posedge clk or posedge rst) begin // ?? cache ???
    if (rst) begin
        cache_stat <= IDLE;
        time_cnt <= 0;
        swap_out_strategy <= LRU;
        //swap_out_strategy <= FIFO;
        for (integer i = 0;
                i < SET_SIZE;
                i = i + 1 ) begin
            for (integer j = 0;
                    j < WAY_CNT ;
                    j = j + 1) begin
                dirty[i][j] = 1'b0;
                valid[i][j] = 1'b0;
                LRU_record[i][j] = 0;
                FIFO_record[j][j] = 0;
            end
        end
        for (integer k = 0;
                k < LINE_SIZE;
                k = k + 1 )
            mem_wr_line[k] <= 0;
        mem_wr_addr <= 0;
        {mem_rd_tag_addr, mem_rd_set_addr} <= 0;
        rd_data <= 0;
    end else
    begin
        time_cnt= time_cnt + 1 ;
        case (cache_stat)
            IDLE: begin
                if (cache_hit) begin
                    if (rd_req) begin // 如果cache命中，并且是读请求，
                        rd_data <= cache_mem[set_addr][way_addr][line_addr]; //则直接从cache中取出要读的数据
                    end else if (wr_req) begin // 如果cache命中，并且是写请求，
                        cache_mem[set_addr][way_addr][line_addr] <= wr_data; // 则直接向cache中写?数据
                        dirty[set_addr][way_addr] <= 1'b1; // 写数据的同时置脏位
                    end
                    LRU_record[set_addr][way_addr] <= time_cnt;
                end else
                begin
                    if (wr_req | rd_req) begin // 如果 cache 未命中，并且有读写请求，则需要进?换入
                        if (valid[set_addr]
                                [out_way] & dirty[set_addr][out_way]) begin // 如果 要换?的cache line 本来有效，且脏，则需要先将它换出
                            cache_stat <= SWAP_OUT;
                            mem_wr_addr <= {cache_tags[set_addr][out_way], set_addr};
                            mem_wr_line <= cache_mem[set_addr][out_way];
                        end else
                        begin // 反之，不需要换出，直接换?
                            cache_stat <= SWAP_IN;
                        end
                        {mem_rd_tag_addr, mem_rd_set_addr} <= {tag_addr, set_addr};
                    end
                end
            end
            SWAP_OUT: begin
                if (mem_gnt) begin // 如果主存握?信号有效，说明换出成功，跳到下?状态
                    cache_stat <= SWAP_IN;
                end
            end
            SWAP_IN: begin
                if (mem_gnt) begin // 如果主存握?信号有效，说明换?成功，跳到下?状态
                    cache_stat <= SWAP_IN_OK;
                end
            end
            SWAP_IN_OK: begin // 上?个周期换?成功，这周期将主存读出的line写?cache，并更新tag，置?valid，置低dirty
                for (integer i = 0;
                        i < LINE_SIZE;
                        i=i+1 )
                    cache_mem[mem_rd_set_addr][out_way][i]<= mem_rd_line[i];
                                               cache_tags[mem_rd_set_addr][out_way] <= mem_rd_tag_addr;
                                               valid [mem_rd_set_addr][out_way] <= 1'b1;
                                               dirty [mem_rd_set_addr][out_way] <= 1'b0;
                                               LRU_record[mem_rd_set_addr][out_way] <= time_cnt;
                                               cache_stat <= IDLE; // 回到就绪状态
                                           end
                                   endcase
                               end
                           end
                           wire mem_rd_req = (cache_stat == SWAP_IN );
wire mem_wr_req = (cache_stat == SWAP_OUT);
wire [ MEM_ADDR_LEN - 1 : 0] mem_addr = mem_rd_req ? mem_rd_addr : ( mem_wr_req ? mem_wr_addr : 0);
assign miss = (rd_req | wr_req) & ~(cache_hit && cache_stat == IDLE) ; // 当 有读写请求时，如果cache不处于就绪(IDLE)状态，或者未命中，则miss=1
main_mem #( // 主存，每次读写以line 为单位
             .LINE_ADDR_LEN ( LINE_ADDR_LEN ),
             .ADDR_LEN ( MEM_ADDR_LEN )
         ) main_mem_instance (
             .clk ( clk ),
             .rst ( rst ),
             .gnt ( mem_gnt ),
             .addr ( mem_addr ),
             .rd_req ( mem_rd_req ),
             .rd_line ( mem_rd_line ),
             .wr_req ( mem_wr_req ),
             .wr_line ( mem_wr_line )
         );
endmodule